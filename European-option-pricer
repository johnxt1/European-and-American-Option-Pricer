import math

# ======================= Binomial Model =======================
class BinModel:
    def __init__(self):
        self.S0 = self.U = self.D = self.R = None

    def get_input_data(self):
        self.S0 = float(input("Enter S0: "))
        self.U = float(input("Enter U: "))
        self.D = float(input("Enter D: "))
        self.R = float(input("Enter R: "))
        print(f"\nS0={self.S0}, U={self.U}, D={self.D}, R={self.R}\n")

        if self.S0 <= 0 or self.U <= 0 or self.D <= 0 or self.U <= self.D or self.R <= 0:
            print("Illegal data ranges"); exit(1)
        if self.R >= self.U or self.R <= self.D:
            print("Arbitrage exists"); exit(1)

        print("Input data checked â€” no arbitrage\n")

    def risk_neut_prob(self):
        return (self.R - self.D) / (self.U - self.D)

    def S(self, n, i):
        return self.S0 * (self.U ** i) * (self.D ** (n - i))


# ======================= Binomial Lattice =======================
class BinLattice:
    def __init__(self):
        self.lattice = []

    def set_size(self, N):
        self.lattice = [[None]*(i+1) for i in range(N+1)]

    def set_node(self, n, i, value):
        self.lattice[n][i] = value

    def get_node(self, n, i):
        return self.lattice[n][i]

    def display(self, title):
        print(f"\n{title}:")
        for row in self.lattice:
            print(' '.join(f"{v:7.3f}" if isinstance(v, (int, float)) else f"{v:7}" for v in row))


# ======================= Option Base Class =======================
class Option:
    def __init__(self):
        self.N = self.K = None

    def payoff(self, S):
        raise NotImplementedError

    # European price by backward induction lattice
    def price_european_lattice(self, model):
        p = model.risk_neut_prob()
        lattice = BinLattice()
        lattice.set_size(self.N)

        # Terminal payoffs
        for i in range(self.N + 1):
            lattice.set_node(self.N, i, self.payoff(model.S(self.N, i)))

        # Backward induction
        for n in range(self.N - 1, -1, -1):
            for i in range(n + 1):
                cont_val = (p * lattice.get_node(n + 1, i + 1) +
                            (1 - p) * lattice.get_node(n + 1, i)) / model.R
                lattice.set_node(n, i, cont_val)

        lattice.display(title="European Price Lattice")
        return lattice.get_node(0, 0)

    # American price with 
    def price_american_lattice(self, model):
        p = model.risk_neut_prob()
        lattice = BinLattice()
        lattice.set_size(self.N)

        # Terminal payoffs
        for i in range(self.N + 1):
            lattice.set_node(self.N, i, self.payoff(model.S(self.N, i)))

        # Backward induction
        for n in range(self.N - 1, -1, -1):
            for i in range(n + 1):
                cont_val = (p * lattice.get_node(n+1, i+1) +
                            (1 - p) * lattice.get_node(n+1, i)) / model.R
                exercise_val = self.payoff(model.S(n, i))
                lattice.set_node(n, i, max(cont_val, exercise_val))

        lattice.display(title="American Price Lattice")
        return lattice.get_node(0, 0)


# ======================= Call and Put Options =======================
class Call(Option):
    def option_data(self):
        print("Enter call data:")
        self.N = int(input("Enter steps to expiry N: "))
        self.K = float(input("Enter strike price K: "))
        print(f"N={self.N}, K={self.K}\n")

    def payoff(self, S):
        return max(S - self.K, 0)


class Put(Option):
    def option_data(self):
        print("Enter put data:")
        self.N = int(input("Enter steps to expiry N: "))
        self.K = float(input("Enter strike price K: "))
        print(f"N={self.N}, K={self.K}\n")

    def payoff(self, S):
        return max(self.K - S, 0)


# ======================= Main Program =======================
def main():
    model = BinModel()
    model.get_input_data()

    # Call option
    call = Call()
    call.option_data()
    print("Call European price =", call.price_european_lattice(model))
    print("Call American price =", call.price_american_lattice(model))
    print()

    # Put option
    put = Put()
    put.option_data()
    print("Put European price =", put.price_european_lattice(model))
    print("Put American price =", put.price_american_lattice(model))
    print()

