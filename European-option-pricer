import math

# ======================= Binomial Model =======================
class BinModel:
    def __init__(self):
        self.S0 = self.U = self.D = self.R = None

    def get_input_data(self):
        self.S0 = float(input("Enter S0: "))
        self.U = float(input("Enter U: "))
        self.D = float(input("Enter D: "))
        self.R = float(input("Enter R: "))
        print(f"\nS0={self.S0}, U={self.U}, D={self.D}, R={self.R}\n")

        if self.S0 <= 0 or self.U <= 0 or self.D <= 0 or self.U <= self.D or self.R <= 0:
            print("Illegal data ranges"); exit(1)
        if self.R >= self.U or self.R <= self.D:
            print("Arbitrage exists"); exit(1)

        print("Input data checked â€” no arbitrage\n")

    def risk_neut_prob(self):
        return (self.R - self.D) / (self.U - self.D)

    def S(self, n, i):
        return self.S0 * (self.U ** i) * (self.D ** (n - i))

# ======================= Binomial Lattice =======================
class BinLattice:
    def __init__(self):
        self.lattice = []

    def set_size(self, N):
        self.lattice = [[None]*(i+1) for i in range(N+1)]

    def set_node(self, n, i, value):
        self.lattice[n][i] = value

    def get_node(self, n, i):
        return self.lattice[n][i]

    def display(self, title):
        print(f"\n{title}:")
        for row in self.lattice:
            print(' '.join(str(int(v)) if isinstance(v, bool) else f"{v:7.3f}" for v in row))

# ======================= Newton's binomial coefficient =======================
def newton_symb(N, n):
    if n < 0 or n > N:
        return 0
    return math.comb(N, n)

# ======================= Option Base Class =======================
class Option:
    def __init__(self):
        self.N = self.K = None

    def payoff(self, S):
        raise NotImplementedError

    # European price by CRR formula at time 0
    def price_european(self, model):
        p = model.risk_neut_prob()
        price = 0.0
        for n in range(self.N + 1):
            price += newton_symb(self.N, n) * (p ** n) * ((1 - p) ** (self.N - n)) \
                     * self.payoff(model.S(self.N, n)) / (model.R ** self.N)
        return price

    # European price at specific node (n,i)
    def price_european_at_node(self, model, n, i):
        p = model.risk_neut_prob()
        remaining_steps = self.N - n
        price = 0.0
        S_current = model.S(n, i)
        for j in range(remaining_steps + 1):
            prob = newton_symb(remaining_steps, j) * (p ** j) * ((1 - p) ** (remaining_steps - j))
            S_N = S_current * (model.U ** j) * (model.D ** (remaining_steps - j))
            price += prob * self.payoff(S_N)
        return price / (model.R ** remaining_steps)

    # American price with Snell envelope
    def price_american_with_trees(self, model):
        p = model.risk_neut_prob()
        price_tree = BinLattice()
        stop_tree = BinLattice()
        price_tree.set_size(self.N)
        stop_tree.set_size(self.N)

        # Terminal payoffs
        for i in range(self.N + 1):
            price_tree.set_node(self.N, i, self.payoff(model.S(self.N, i)))
            stop_tree.set_node(self.N, i, True)  # Exercise at terminal

        # Backward induction
        for n in range(self.N - 1, -1, -1):
            for i in range(n + 1):
                cont_val = (p * price_tree.get_node(n+1, i+1) +
                            (1-p) * price_tree.get_node(n+1, i)) / model.R
                exercise_val = self.payoff(model.S(n, i))
                if cont_val > exercise_val:
                    price_tree.set_node(n, i, cont_val)
                    stop_tree.set_node(n, i, False)  # Continue
                else:
                    price_tree.set_node(n, i, exercise_val)
                    stop_tree.set_node(n, i, True)   # Exercise
        return price_tree, stop_tree

# ======================= Call and Put Options =======================
class Call(Option):
    def option_data(self):
        print("Enter call data:")
        self.N = int(input("Enter steps to expiry N: "))
        self.K = float(input("Enter strike price K: "))
        print(f"N={self.N}, K={self.K}\n")

    def payoff(self, S):
        return max(S - self.K, 0)

class Put(Option):
    def option_data(self):
        print("Enter put data:")
        self.N = int(input("Enter steps to expiry N: "))
        self.K = float(input("Enter strike price K: "))
        print(f"N={self.N}, K={self.K}\n")

    def payoff(self, S):
        return max(self.K - S, 0)

# ======================= Main Program =======================
def main():
    # Initialize the binomial model
    model = BinModel()
    model.get_input_data()

    # Ask user which option type (c/p)
    option_type = input("Enter option type (c=Call, p=Put): ").strip().lower()
    if option_type == "c":
        option = Call()
    elif option_type == "p":
        option = Put()
    else:
        print("Invalid input, defaulting to Put.")
        option = Put()
    option.option_data()  # Ask for strike and steps

    # Ask user European or American (e/a)
    option_style = input("Enter option style (e=European, a=American): ").strip().lower()
    if option_style not in ('e', 'a'):
        print("Invalid input, defaulting to European.")
        option_style = 'e'

    # Ask if user wants price at a specific node
    specific_node = input("Price at specific node? (y/n): ").strip().lower()

    if specific_node == 'y':
        n = int(input("Enter node n (time step): "))
        i = int(input("Enter node i: "))
        if option_style == 'e':
            price = option.price_european_at_node(model, n, i)
            print(f"European option price at node ({n},{i}) = {price:.3f}")
        else:
            price_tree, stop_tree = option.price_american_with_trees(model)
            price = price_tree.get_node(n, i)
            exercise = stop_tree.get_node(n, i)
            print(f"American option price at node ({n},{i}) = {price:.3f}")
            print(f"Exercise? {'Yes' if exercise else 'No'}")
    else:
        if option_style == 'e':
            price = option.price_european(model)
            print(f"European option price at time 0 = {price:.3f}")
            price_tree = option.price_european_tree(model)
            price_tree.display(title="European Option Price Tree")
        else:
            price_tree, stop_tree = option.price_american_with_trees(model)
            print(f"American option price at time 0 = {price_tree.get_node(0,0):.3f}")
            price_tree.display(title="American Option Price Tree")
            stop_tree.display(title="American Option Stopping Tree")
