import math

# ======================= Binomial Model =======================
class BinModel:
    def __init__(self):
        self.S0 = self.U = self.D = self.R = None

    def get_input_data(self):
        self.S0 = float(input("Enter S0: "))
        self.U = float(input("Enter U: "))
        self.D = float(input("Enter D: "))
        self.R = float(input("Enter R: "))
        print(f"\nS0={self.S0}, U={self.U}, D={self.D}, R={self.R}\n")

        if self.S0 <= 0 or self.U <= 0 or self.D <= 0 or self.U <= self.D or self.R <= 0:
            print("Illegal data ranges"); exit(1)
        if self.R >= self.U or self.R <= self.D:
            print("Arbitrage exists"); exit(1)

        print("Input data checked â€” no arbitrage\n")

    def risk_neut_prob(self):
        return (self.R - self.D) / (self.U - self.D)

    def S(self, n, i):
        return self.S0 * (self.U ** i) * (self.D ** (n - i))

# ======================= Binomial Lattice =======================
class BinLattice:
    def __init__(self):
        self.lattice = []

    def set_size(self, N):
        self.lattice = [[None]*(i+1) for i in range(N+1)]

    def set_node(self, n, i, value):
        self.lattice[n][i] = value

    def get_node(self, n, i):
        return self.lattice[n][i]

    def display(self, title):
        print(f"\n{title}:")
        for row in self.lattice:
            print(' '.join(str(int(v)) if isinstance(v, bool) else f"{v:7.3f}" for v in row))

# ======================= Option Base Class =======================
class Option:
    def __init__(self):
        self.N = self.K = None

    def payoff(self, S):
        raise NotImplementedError

    # European price tree via backward induction
    def price_european_with_tree(self, model):
        p = model.risk_neut_prob()
        tree = BinLattice()
        tree.set_size(self.N)

        # Terminal payoffs
        for i in range(self.N+1):
            tree.set_node(self.N, i, self.payoff(model.S(self.N, i)))

        # Backward induction
        for n in range(self.N-1, -1, -1):
            for i in range(n+1):
                cont_val = (p*tree.get_node(n+1, i+1) + (1-p)*tree.get_node(n+1, i)) / model.R
                tree.set_node(n, i, cont_val)
        return tree

    # American price with Snell envelope
    def price_american_with_trees(self, model):
        p = model.risk_neut_prob()
        price_tree = BinLattice()
        stop_tree = BinLattice()
        price_tree.set_size(self.N)
        stop_tree.set_size(self.N)

        # Terminal payoffs
        for i in range(self.N+1):
            price_tree.set_node(self.N, i, self.payoff(model.S(self.N, i)))
            stop_tree.set_node(self.N, i, True)

        # Backward induction
        for n in range(self.N-1, -1, -1):
            for i in range(n+1):
                cont_val = (p*price_tree.get_node(n+1, i+1) + (1-p)*price_tree.get_node(n+1, i)) / model.R
                exercise_val = self.payoff(model.S(n, i))
                if cont_val > exercise_val:
                    price_tree.set_node(n, i, cont_val)
                    stop_tree.set_node(n, i, False)
                else:
                    price_tree.set_node(n, i, exercise_val)
                    stop_tree.set_node(n, i, True)
        return price_tree, stop_tree

# ======================= Call and Put Options =======================
class Call(Option):
    def option_data(self):
        print("Enter call data:")
        self.N = int(input("Enter steps to expiry N: "))
        self.K = float(input("Enter strike price K: "))
        print(f"N={self.N}, K={self.K}\n")

    def payoff(self, S):
        return max(S - self.K, 0)

class Put(Option):
    def option_data(self):
        print("Enter put data:")
        self.N = int(input("Enter steps to expiry N: "))
        self.K = float(input("Enter strike price K: "))
        print(f"N={self.N}, K={self.K}\n")

    def payoff(self, S):
        return max(self.K - S, 0)

# ======================= Hedging Helper =======================
def compute_hedge_backwards(model, option, n, i, price_tree):
    """
    Compute hedging portfolio at node (n, i)
    - x: stock holding
    - y: cash holding
    """
    # Values at next step
    V_up = price_tree.get_node(n + 1, i + 1)
    V_down = price_tree.get_node(n + 1, i)

    # Stock prices at next step
    S_up = model.S(n + 1, i + 1)
    S_down = model.S(n + 1, i)

    # Delta (stock holding)
    x = (V_up - V_down) / (S_up - S_down)

    # Cash position
    V_now = price_tree.get_node(n, i)
    S_now = model.S(n, i)
    y = V_now - x * S_now

    return x, y

# ======================= Main Program =======================
def main():
    # Initialize the binomial model
    model = BinModel()
    model.get_input_data()

    # Option style
    option_style = input("Enter option style (e=European, a=American): ").strip().lower()
    option_style = 'a' if option_style == 'a' else 'e'

    # Option type
    option_type = input("Enter option type (c=Call, p=Put): ").strip().lower()
    option = Call() if option_type == 'c' else Put()
    option.option_data()

    # Price at specific node?
    specific_node = input("Price at specific node? (y/n): ").strip().lower()

    if specific_node == 'y':
        n = int(input("Enter node n (time step): "))
        i = int(input("Enter node i: "))

        if option_style == 'e':
            price_tree = option.price_european_with_tree(model)
            price = price_tree.get_node(n, i)
            print(f"European option price at node ({n},{i}) = {price:.3f}")
        else:
            price_tree, stop_tree = option.price_american_with_trees(model)
            price = price_tree.get_node(n, i)
            exercise = stop_tree.get_node(n, i)
            print(f"American option price at node ({n},{i}) = {price:.3f}")
            print(f"Exercise? {'Yes' if exercise else 'No'}")

        # Hedging portfolio
        x, y = compute_hedge_backwards(model, option, n, i, price_tree)
        print(f"Hedging portfolio: stock = {x:.3f}, cash = {y:.3f}")

    else:
        if option_style == 'e':
            price_tree = option.price_european_with_tree(model)
            price = price_tree.get_node(0,0)
            print(f"European option price at time 0 = {price:.3f}")
            price_tree.display(title="European Option Price Tree")
        else:
            price_tree, stop_tree = option.price_american_with_trees(model)
            print(f"American option price at time 0 = {price_tree.get_node(0,0):.3f}")
            price_tree.display(title="American Option Price Tree")
            stop_tree.display(title="American Option Exercise Tree")

    main()
