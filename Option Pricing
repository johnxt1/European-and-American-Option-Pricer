import math

# ======================= Binomial Model =======================
class BinModel:
    def __init__(self):
        self.S0 = self.U = self.D = self.R = None

    def get_input_data(self):
        print("Enter input data in multiplicative form (e.g., U=1.1, D=0.9, R=1.02)")
        self.S0 = float(input("Enter initial stock price S0 : "))
        self.U = float(input("Enter up factor U: "))
        self.D = float(input("Enter down factor D: "))
        self.R = float(input("Enter risk-free rate R: "))
        print(f"\nS0={self.S0}, U={self.U}, D={self.D}, R={self.R}\n")

        if self.S0 <= 0 or self.U <= 0 or self.D <= 0 or self.U <= self.D or self.R <= 0:
            print("Illegal data ranges"); exit(1)
        if self.R >= self.U or self.R <= self.D:
            print("Arbitrage exists"); exit(1)

        print("Input data checked â€” no arbitrage\n")

    def risk_neut_prob(self):
        return (self.R - self.D) / (self.U - self.D)

    def S(self, n, i):
        return self.S0 * (self.U ** i) * (self.D ** (n - i))

# ======================= Binomial Lattice =======================
class BinLattice:
    def __init__(self):
        self.lattice = []

    def set_size(self, N):
        self.lattice = [[None]*(i+1) for i in range(N+1)]

    def set_node(self, n, i, value):
        self.lattice[n][i] = value

    def get_node(self, n, i):
        return self.lattice[n][i]
    
    def display(self, title):
        print(f"\n{title}:")
        for n, row in enumerate(self.lattice):
            print(f"n={n}  " + '   '.join(f"{int(v) if isinstance(v, bool) else f'{v:7.3f}'}" for v in row))
   
# ======================= Option Base Class =======================
class Option:
    def __init__(self):
        self.N = self.K = None

    def payoff(self, S):
        raise NotImplementedError

    # European price tree via backward induction
    def price_european(self, model):
        p = model.risk_neut_prob()
        price_tree = BinLattice()
        price_tree.set_size(self.N)

        # Terminal payoffs
        for i in range(self.N+1):
            price_tree.set_node(self.N, i, self.payoff(model.S(self.N, i)))

        # Backward induction
        for n in range(self.N-1, -1, -1):
            for i in range(n+1):
                cont_val = (p*price_tree.get_node(n+1, i+1) + (1-p)*price_tree.get_node(n+1, i)) / model.R
                price_tree.set_node(n, i, cont_val)
        return price_tree

    # American price tree
    def price_american(self, model):
        p = model.risk_neut_prob()
        price_tree = BinLattice()
        stop_tree = BinLattice()
        price_tree.set_size(self.N)
        stop_tree.set_size(self.N)

        # Terminal payoffs
        for i in range(self.N+1):
            price_tree.set_node(self.N, i, self.payoff(model.S(self.N, i)))
            stop_tree.set_node(self.N, i, True)

        # Backward induction
        for n in range(self.N-1, -1, -1):
            for i in range(n+1):
                cont_val = (p*price_tree.get_node(n+1, i+1) + (1-p)*price_tree.get_node(n+1, i)) / model.R
                exercise_val = self.payoff(model.S(n, i))
                if cont_val > exercise_val:
                    price_tree.set_node(n, i, cont_val)
                    stop_tree.set_node(n, i, False)
                else:
                    price_tree.set_node(n, i, exercise_val)
                    stop_tree.set_node(n, i, True)
        return price_tree, stop_tree

# ======================= Call and Put Options =======================
class Call(Option):
    def option_data(self):
        print("Enter call data:")
        self.N = int(input("Enter steps to expiry N: "))
        self.K = float(input("Enter strike price K: "))
        print(f"N={self.N}, K={self.K}\n")

        if self.N<0 or self.K<0:
            print('N, K must be positive');exit(1)

    def payoff(self, S):
        return max(S - self.K, 0)

class Put(Option):
    def option_data(self):
        print("Enter put data:")
        self.N = int(input("Enter steps to expiry N: "))
        self.K = float(input("Enter strike price K: "))
        print(f"N={self.N}, K={self.K}\n")

        if self.N<0 or self.K<0:
            print('N, K must be positive');exit(1)

    def payoff(self, S):
        return max(self.K - S, 0)

# ======================= Hedging =======================
def compute_hedging(model, option, n, i, price_tree):
    """
    Compute hedging portfolio at node (n, i)
    - x: stock position
    - y: cash position
    """
    # Values at next step
    V_up = price_tree.get_node(n + 1, i + 1)
    V_down = price_tree.get_node(n + 1, i)

    # Stock prices at next step
    S_up = model.S(n + 1, i + 1)
    S_down = model.S(n + 1, i)

    # Stock position
    x = (V_up - V_down) / (S_up - S_down)

    # Risk free asset position
    V_now = price_tree.get_node(n, i)
    S_now = model.S(n, i)
    y = V_now - x * S_now

    return x, y

# ======================= Main Program =======================
def main():
    # Initialize the binomial model
    model = BinModel()
    model.get_input_data()

    # Option style
    option_style = input("Enter option style (e=European, a=American): ").strip().lower()
    option_style = 'a' if option_style == 'a' else 'e'

    # Option type
    option_type = input("Enter option type (c=Call, p=Put): ").strip().lower()
    option = Call() if option_type == 'c' else Put()
    option.option_data()

    # Price at specific node?
    specific_node = input("Price at specific node? (y/n): ").strip().lower()

    if specific_node == 'y':
        n = int(input("Enter node n (time step): "))
        i = int(input("Enter node i: "))

        if option_style == 'e':
            price_tree = option.price_european(model)
            price = price_tree.get_node(n, i)
            print(f"European option price at node ({n},{i}) = {price:.3f}")
        else:
            price_tree, stop_tree = option.price_american(model)
            price = price_tree.get_node(n, i)
            exercise = stop_tree.get_node(n, i)
            print(f"American option price at node ({n},{i}) = {price:.3f}")
            print(f"Exercise? {'Yes' if exercise else 'No'}")

        # Hedging portfolio
        x, y = compute_hedging(model, option, n, i, price_tree)
        print(f"Hedging portfolio: stock = {x:.3f}, risk free asset = {y:.3f}")

    else:
        if option_style == 'e':
            price_tree = option.price_european(model)
            price = price_tree.get_node(0,0)
            print(f"European option price at time 0 = {price:.3f}")
            price_tree.display(title="European Option Price Tree")
        else:
            price_tree, stop_tree = option.price_american(model)
            price = price_tree.get_node(0,0)
            print(f"American option price at time 0 = {price:.3f}")
            price_tree.display(title="American Option Price Tree")   
            stop_tree.display(title="American Option Exercise Tree (1 = exercise, 0 = continue)")
main()
